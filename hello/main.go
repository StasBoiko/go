package main

import (
	"fmt"
	"sort"
)

// import (
// 	"encoding/json"
// 	"fmt"
// "./test"
// tour "hello"
// )

// Exercise: Loops and Functions
// func Sqrt(x float64) float64 {
// 	z := 1.0
// 	for i := 0; i < 10; i++ {
// 		z -= (z*z - x) / (2*z)
// 	}

// 	return z
// }

// func main() {
// 	foo := Sqrt(2)
// 	fmt.Println(foo)
// }

// Exercise: Slices
// import "golang.org/x/tour/pic"

// func Pic(dx, dy int) [][]uint8 {
// 	p := make([][]uint8, dy)
//     for y := range p {
//         p[y] = make([]uint8, dx)
//         for x := range p[y] {
// 			p[y][x] = uint8(x^y)
//         }
//     }
//     return p
// }

// func main() {
// 	pic.Show(Pic)
// }

// Exercise: Maps
// func WordCount(s string) map[string]int {
// 	m := make(map[string]int)
// 	for _, v := range strings.Fields(s) {
// 		m[v] += 1
// 	}
// 	return m
// }

// Exercise: Fibonacci closure
// func fibonacci() func(nextTerm int) int {
// 	return func(nextTerm int) int {
// 		return nextTerm
// 	}
// }

// func main() {
// 	t1 := 0
// 	t2 := 1
// 	nextTerm := t1 + t2
// 	f := fibonacci()
// 	for i := 0; i < 10; i++ {
// 		fmt.Println(f(nextTerm))
// 		t1 = t2
// 		t2 = nextTerm
// 		nextTerm = t1 + t2
// 	}
// }

// func main() {
// 	m := make(map[string]int)

// 	for _, v := range strings.Fields("i am good") {
// 		m[v] = len(v)
// 	}
// 	fmt.Println(m)
// }

// fibonacci is a function that returns
// a function that returns an int.
// func fibonacci() func(nextTerm int) int {
// 	return func(nextTerm int) int {
// 		return nextTerm
// 	}
// }

// func main() {
// 	t1 := 0
// 	t2 := 1
// 	nextTerm := t1 + t2
// 	f := fibonacci()
// 	for i := 0; i < 10; i++ {
// 		fmt.Println(f(nextTerm))
// 		t1 = t2
// 		t2 = nextTerm
// 		nextTerm = t1 + t2
// 	}
// }

// Exercise: Stringers
// type IPAddr [4]byte

// func (ip IPAddr) String() string {
// 	return fmt.Sprintf("%v.%v.%v.%v", ip[0], ip[1], ip[2], ip[3])
// }

// func (key StasMap) String() string {
// 	return fmt.Sprintf("%v", "myNewKey")
// }

// type StasMap string

// func main() {
// 	hosts := map[StasMap]IPAddr{
// 		"loopback":  {127, 0, 0, 1},
// 		"googleDNS": {8, 8, 8, 8},
// 	}
// 	for key, ip := range hosts {
// 		fmt.Printf("%v %v \n", key, ip)
// 	}
// }

// Не получилось:
// Exercise: Readers
// package main

// import (
// 	"golang.org/x/tour/reader"
// )

// type MyReader struct{}

// // TODO: Add a Read([]byte) (int, error) method to MyReader.
// func (r MyReader) Read(b []byte) (int, error) {
// 	b[0] = 'A'
// 	return 0, nil
// }

// func main() {
// 	reader.Validate(MyReader{})
// }

// type animal interface {
// 	breathe()
// 	walk()
// }

// type lion struct {
// 	age int
// }

// func (l lion) breathe() {
// 	fmt.Println("Lion breathes")
// }

// func (l lion) walk() {
// 	fmt.Println("Lion walk")
// }

// type dog struct {
// 	age int
// }

// func (d dog) breathe() {
// 	fmt.Println("Dog breathes")
// }

// func (d dog) walk() {
// 	fmt.Println("Dog walk")
// }

// func main() {
// 	var a animal

// 	a = lion{age: 10}
// 	print(a)

// }

// func print(a animal) {
// 	switch v := a.(type) {
// 	case lion:
// 		fmt.Println("Type: lion")
// 	case dog:
// 		fmt.Println("Type: dog")
// 	default:
// 		fmt.Printf("Unknown Type %T", v)
// 	}
// }

// type AutoGenerated struct {
// 	Accountid  string `json:"accountid"`
// 	Name       string `json:"name"`
// 	Paymentid  string `json:"paymentid"`
// 	Sequence   int64  `json:"sequence"`
// 	Paymentrow []struct {
// 		Date   string  `json:"date"`
// 		Amount float64 `json:"amount"`
// 	} `json:"paymentrow"`
// }

// func main() {
// 	jsonData := `{
// 		"accountid": "162",
// 		"name": "myclient",
// 		"paymentid": "A345345",
// 		"sequence": 3977318850,
// 		"paymentrow": [{
// 			"date": "2012-June-20",
// 			"amount": 457.18
// 		}, {
// 			"date": "2018-Jul-22",
// 			"amount": 137.18
// 		}]
// 	  }`

// 	someData := AutoGenerated{}
// 	err := json.Unmarshal([]byte(jsonData), &someData)
// 	if err != nil {
// 		fmt.Println(err)
// 	}
// 	//a := make(map[string]interface{})

// 	for _, val := range someData.Paymentrow {
// 		//j, _ := json.Marshal(val)
// 		//fmt.Println(j)
// 		fmt.Println(val)
// 	}

// a := make(map[string]interface{})
// a[1] = "John"

// j, err := json.Marshal(a)
// if err != nil {
// 	fmt.Printf("Error: %s", err.Error())
// } else {
// 	fmt.Println(string(j))
// }

// var b map[int]string
// json.Unmarshal(j, &b)

// fmt.Println(b)
//fmt.Println(someData.Paymentrow[0])
//fmt.Println(someData.Paymentrow[1])
// }

//func isJSONString(s string) bool {
//	var js string
//	return json.Unmarshal([]byte(s), &js) == nil
//
//}
//
//func isJSON(s string) bool {
//	var js map[string]interface{}
//	return json.Unmarshal([]byte(s), &js) == nil
//
//}

//func main() {
//var tests = []string{
//	`"Platypus"`,
//	`Platypus`,
//	`{"id":"1"}`,
//}
//
//for _, t := range tests {
//	fmt.Printf("isJSONString(%s) = %v\n", t, isJSONString(t))
//	fmt.Printf("isJSON(%s) = %v\n\n", t, isJSON(t))
//}
//	scanner := bufio.NewScanner(os.Stdin)
//	for scanner.Scan() {
//		fmt.Println(scanner.Text())
//	}
//}

type byLength []string

func (s byLength) Len() int {
	return len(s)
}
func (s byLength) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}
func (s byLength) Less(i, j int) bool {
	return len(s[i]) < len(s[j])
}
func main() {
	fruits := []string{"peach", "banana", "kiwi"}
	sort.Sort(byLength(fruits))
	fmt.Println(fruits)
}
